<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Quest VR デモ – 青空 + 草地 + オブジェクト</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    #startVR {
      position:fixed; top:20px; left:20px; z-index:10;
      padding:10px 20px; font-size:1.2em;
      background:#4CAF50; color:#fff; border:none; border-radius:5px;
      cursor:pointer;
    }
  </style>
</head>
<body>
<button id="startVR">VRモード開始</button>

<!-- ――― すべて ES Modules で ――― -->
<script type="module">
import * as THREE           from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';
import { OrbitControls }    from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/OrbitControls.js'; // PC デバッグ用
import { Sky }              from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/objects/Sky.js';
import { GLTFLoader }       from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/loaders/GLTFLoader.js';

/* ───── 基本セットアップ ───────────────────────── */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize( innerWidth, innerHeight );
renderer.xr.enabled = true;
renderer.shadowMap.enabled = true;
document.body.appendChild( renderer.domElement );

const scene = new THREE.Scene();

/* カメラとプレイヤーリグ */
const playerRig = new THREE.Group();
scene.add( playerRig );

const camera = new THREE.PerspectiveCamera( 70, innerWidth / innerHeight, 0.1, 1000 );
camera.position.set( 0, 1.6, 3 );
playerRig.add( camera );

/* ――― 青空 ――― */
const sky = new Sky();
sky.scale.setScalar( 450000 );
scene.add( sky );
const sun = new THREE.Vector3();
sun.setFromSphericalCoords( 1, THREE.MathUtils.degToRad(90-20), THREE.MathUtils.degToRad(180) ); // 高度 20°
sky.material.uniforms[ 'sunPosition' ].value.copy( sun );
sky.material.uniforms[ 'turbidity' ].value    = 10;
sky.material.uniforms[ 'rayleigh' ].value     = 2;
sky.material.uniforms[ 'mieCoefficient' ].value = 0.003;
sky.material.uniforms[ 'mieDirectionalG' ].value = 0.9;

/* ――― 地面（草テクスチャ）――― */
const tex = new THREE.TextureLoader().load(
  'https://dl.polyhaven.org/file/ph-assets/Textures/jpg/2k/grass_short_01/grass_short_01_diff_2k.jpg',
  t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set( 200, 200 ); }
);
tex.colorSpace = THREE.SRGBColorSpace;
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry( 1000, 1000 ),
  new THREE.MeshStandardMaterial( { map: tex } )
);
ground.rotation.x = - Math.PI / 2;
ground.receiveShadow = true;
scene.add( ground );

/* ――― 環境ライト & 太陽光 ――― */
scene.add( new THREE.HemisphereLight( 0xffffff, 0x444444, 0.4 ) );
const dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
dirLight.position.set( 100, 200, 100 );
dirLight.castShadow = true;
dirLight.shadow.mapSize.set( 2048, 2048 );
scene.add( dirLight );

/* ――― 例: 木の GLB モデルを配置 ――― */
const gltfLoader = new GLTFLoader();
gltfLoader.load(
  'https://threejs.org/examples/models/gltf/Tree.glb',
  glb => {
    const tree = glb.scene;
    tree.traverse( o => { if ( o.isMesh ) { o.castShadow = true; } } );
    tree.position.set( 5, 0, -8 );
    scene.add( tree );
  }
);

/* ――― デバッグ用 OrbitControls (PC で確認しやすい) ――― */
const controls = new OrbitControls( camera, renderer.domElement );
controls.enabled = !renderer.xr.enabled;

/* ───── 入力 / 物理パラメータ ─────────────────── */
const MOVE = 0.05, ROT = 0.03, JUMP = 0.18, GRAV = 0.0098;
const tmpFwd = new THREE.Vector3(), tmpSide = new THREE.Vector3();
playerRig.userData.yVel = 0;
playerRig.userData.canJump = true;

/* ───── Animation Loop ─────────────────────────── */
renderer.setAnimationLoop( ( _, frame ) => {

  const session = renderer.xr.getSession();
  if ( session && frame ) {
    for ( const src of session.inputSources ) {
      if ( !src.gamepad ) continue;
      const g  = src.gamepad;
      const xi = g.axes.length >= 4 ? 2 : 0;
      const yi = xi + 1;
      const x  = g.axes[ xi ];
      const y  = g.axes[ yi ];

      /* 初回: ボタン履歴を確保 */
      if ( !src.userData.prev ) src.userData.prev = g.buttons.map( b => b.pressed );

      if ( src.handedness === 'left' ) {
        /* 左スティックで移動 */
        if ( Math.hypot( x, y ) > 0.1 ) {
          camera.getWorldDirection( tmpFwd ); tmpFwd.y = 0; tmpFwd.normalize();
          tmpSide.crossVectors( camera.up, tmpFwd ).normalize();
          playerRig.position
                   .addScaledVector( tmpFwd, -y * MOVE )
                   .addScaledVector( tmpSide, -x * MOVE );  // 左右反転
        }
      } else if ( src.handedness === 'right' ) {
        /* 右スティック左右で回転 */
        if ( Math.abs( x ) > 0.15 ) {
          playerRig.rotation.y -= x * ROT;
        }
        /* A ボタン( index 0 ) でジャンプ */
        const aNow  = g.buttons[0]?.pressed || false;
        const aPrev = src.userData.prev[0]  || false;
        if ( aNow && !aPrev && playerRig.userData.canJump ) {
          playerRig.userData.yVel  = JUMP;
          playerRig.userData.canJump = false;
        }
      }
      src.userData.prev = g.buttons.map( b => b.pressed );
    }
  }

  /* ジャンプ物理 */
  if ( !playerRig.userData.canJump ) {
    playerRig.position.y += playerRig.userData.yVel;
    playerRig.userData.yVel -= GRAV;
    if ( playerRig.position.y <= 0 ) {
      playerRig.position.y = 0;
      playerRig.userData.yVel = 0;
      playerRig.userData.canJump = true;
    }
  }

  renderer.render( scene, camera );
});

/* ───── VR セッション開始 ───────────────────── */
document.getElementById( 'startVR' ).addEventListener( 'click', async () => {
  if ( !navigator.xr ) { alert( 'WebXR 非対応' ); return; }
  try {
    const s = await navigator.xr.requestSession( 'immersive-vr', { optionalFeatures:[ 'local-floor' ] } );
    const ref = await s.requestReferenceSpace( 'local-floor' ).catch( () => s.requestReferenceSpace( 'local' ) );
    renderer.xr.setReferenceSpace( ref );
    renderer.xr.setSession( s );
  } catch ( e ) { alert( 'VR 開始失敗: ' + e.message ); }
});

/* ───── ウィンドウリサイズ対応 ───────────────── */
addEventListener( 'resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( innerWidth, innerHeight );
});
</script>
</body>
</html>
