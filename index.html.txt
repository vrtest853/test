<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"/>
	<title>Quest WebXR Starter</title>
	<style>body{margin:0;overflow:hidden;background:#000}</style>

	<!-- ★ three.js r176 を CDN から読み込む。examples は importmap で束ねる -->
	<script type="importmap">
	{
	  "imports":{
	    "three":"https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
	    "three/addons/":"https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/"
	  }
	}
	</script>
</head>
<body>

<script type="module">
////////////////////////////////////////////////////////////
// 0) 依存モジュール
////////////////////////////////////////////////////////////
import * as THREE from 'three';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

////////////////////////////////////////////////////////////
// 1) シーン基本セットアップ
////////////////////////////////////////////////////////////
const scene   = new THREE.Scene();
const camera  = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 100);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

scene.add(new THREE.AmbientLight(0xffffff, 0.3));
const dir = new THREE.DirectionalLight(0xffffff, 1);
dir.position.set(5, 10, 2);
scene.add(dir);

/* ★ GridHelper は core クラスなので import 不要 */
const grid = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
scene.add(grid);

////////////////////////////////////////////////////////////
// 2) プレイヤーリグ（歩行／回転用）
////////////////////////////////////////////////////////////
const player = new THREE.Group();
player.position.set(0, 1.6, 3);        // 初期視点高さ = 1.6 m
player.add(camera);
scene.add(player);

////////////////////////////////////////////////////////////
// 3) サンプルオブジェクト（レーザーで色が変わる）
////////////////////////////////////////////////////////////
const boxGeo = new THREE.BoxGeometry(0.4,0.4,0.4);
const boxMat = new THREE.MeshStandardMaterial({color:0x00aaff});
const cube   = new THREE.Mesh(boxGeo, boxMat);
cube.position.set(0,1.4,-2);
scene.add(cube);

////////////////////////////////////////////////////////////
// 4) コントローラ & レーザー
////////////////////////////////////////////////////////////
const controllerModelFactory = new XRControllerModelFactory();
const rayGeom = new THREE.BufferGeometry().setFromPoints(
  [new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]
);

const controllers = [];
[0,1].forEach(i=>{
  const ctrl = renderer.xr.getController(i);
  ctrl.add(new THREE.Line(rayGeom, new THREE.LineBasicMaterial({color:0xffff00})));
  ctrl.userData.raycaster = new THREE.Raycaster();
  ctrl.addEventListener('selectstart', onSelect);
  scene.add(ctrl);

  const grip = renderer.xr.getControllerGrip(i);
  grip.add(controllerModelFactory.createControllerModel(grip));
  scene.add(grip);

  controllers.push(ctrl);
});

function onSelect(e){
  const tgt = intersect(e.target);
  if (tgt) tgt.material.color.setHex(Math.random()*0xffffff);
}

function intersect(ctrl){
  const m = new THREE.Matrix4().extractRotation(ctrl.matrixWorld);
  ctrl.userData.raycaster.ray.origin.setFromMatrixPosition(ctrl.matrixWorld);
  ctrl.userData.raycaster.ray.direction.set(0,0,-1).applyMatrix4(m);
  const hit = ctrl.userData.raycaster.intersectObject(cube);
  return hit[0]?.object ?? null;
}

////////////////////////////////////////////////////////////
// 5) スティック移動／スナップ回転
////////////////////////////////////////////////////////////
const clock = new THREE.Clock();
const walkSpeed = 3;                     // m/s
const snap = THREE.MathUtils.degToRad(30);
let prevX = 0;

function handleGamepad(ctrl, dt){
  const gp = ctrl?.inputSource?.gamepad;
  if(!gp) return;
  const [x, y] = gp.axes;

  // 前後移動
  if(Math.abs(y) > 0.2){
    const dir = new THREE.Vector3(0,0,-y*dt*walkSpeed).applyQuaternion(camera.quaternion);
    player.position.add(dir);
  }

  // スナップ回転
  if(Math.abs(x) > 0.6 && Math.abs(prevX) <= 0.6){
    player.rotation.y -= Math.sign(x)*snap;
  }
  prevX = x;
}

////////////////////////////////////////////////////////////
// 6) レンダーループ
////////////////////////////////////////////////////////////
renderer.setAnimationLoop(()=>{
  const dt = clock.getDelta();
  controllers.forEach(c=>handleGamepad(c, dt));
  renderer.render(scene, camera);
});

////////////////////////////////////////////////////////////
// 7) リサイズ対応
////////////////////////////////////////////////////////////
addEventListener('resize',()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>